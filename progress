#!/usr/bin/env python3

# This software is distributed under the "Simplified BSD license":
#
# Copyright Michael Cook <michael@waxrat.com>. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#    1. Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#
#    2. Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import os
import logging
import time
import signal
from typing import Any
from stat import S_ISREG, S_ISBLK
import click
from mcook import gmk

Lines = list[str]

def put(lines: Lines, fmt: str, **kwargs: Any) -> None:
    lines.append(f'{time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())} {fmt.format(**kwargs)}')

class File:
    def __init__(self, name: str, pos: int, size: int, timestamp: float) -> None:
        self.name = name
        self.pos = pos
        self.size = size
        self.timestamp = timestamp
        self.first_pos = pos
        self.first_size = size
        self.first_timestamp = timestamp
        self.shown = False

Fds = dict[tuple[str, int, int], File]

class Process:
    def __init__(self, command: str, fds: Fds) -> None:
        self.command = command
        self.fds = fds

Procs = dict[int, Process]

def get_procs() -> Procs:
    procs: Procs = {}
    timestamp = time.time()
    for pid in os.listdir('.'):
        if not pid[0].isdigit():
            continue
        logging.debug('== %s ==', pid)

        fddir = pid + '/fd/'
        try:
            fds = os.listdir(fddir)
        except OSError as exc:
            logging.debug('skip %s %s', pid, exc)
            continue

        try:
            with open(f'{pid}/comm', encoding='utf-8') as f:
                command = f.read().rstrip('\n')
        except IOError as exc:
            logging.debug('skip %s %s', pid, exc)
            continue

        fdmap = {}
        for fd in fds:
            try:
                fdfile = fddir + fd
                st = os.stat(fdfile)
                logging.debug('fd %s %s', fd, st)

                if not (S_ISREG(st.st_mode) or not S_ISBLK(st.st_mode)):
                    logging.debug('not regular or block %s', fd)
                    continue

                name = os.readlink(fdfile)
                logging.debug('name %s', name)

                size = st.st_size
                pos = 0
                with open(f'{pid}/fdinfo/{fd}', 'rt', encoding='utf-8') as f:
                    for line in f:
                        logging.debug('fdinfo: %r', line)
                        if line.startswith('pos:'):
                            pos = int(line[4:])
                            break
                logging.debug('pos %s of %s', pos, size)

                fdmap[fd, st.st_dev, st.st_ino] = \
                    File(name=name, pos=pos, size=size, timestamp=timestamp)

            except OSError as exc:
                logging.debug('skip %s %s %s', pid, fd, exc)

        procs[int(pid)] = Process(command=command, fds=fdmap)
    return procs

def percentage(n: int, d: int) -> str:
    """
    Returns a string like '12.3%' from numerator N and denominator D
    """
    if d == 0:
        return '-'
    per = 100.0 * n / d
    r = f'{per:.1f}%'
    if r == '100.0%':
        r = '100%'
    return r

def compare_proc(lines: Lines, then_proc: Process, now_proc: Process) -> None:
    for (fd, dev, ino), now_fd in now_proc.fds.items():
        then_fd = then_proc.fds.pop((fd, dev, ino), None)
        if not then_fd:
            continue
        now_fd.first_pos = then_fd.first_pos
        now_fd.first_size = then_fd.first_size
        now_fd.first_timestamp = then_fd.first_timestamp
        now_fd.shown = then_fd.shown
        if now_fd.size == 0 and then_fd.size == 0:
            continue
        if now_fd.pos == then_fd.pos:
            continue
        now_fd.shown = True

        rate = '-'
        more_time = '-'
        elapsed = now_fd.timestamp - now_fd.first_timestamp
        if elapsed != 0:
            bytes_per_sec = (now_fd.pos - now_fd.first_pos) / elapsed
            if bytes_per_sec > 0:
                rate = gmk(bytes_per_sec) + 'B/s'
                more_bytes = now_fd.size - now_fd.pos
                if more_bytes > 0:
                    s = int(more_bytes / bytes_per_sec)
                    more_time = f'{s // 60:d}:{s % 60:02d}'

        if now_fd.pos == now_fd.size:
            continue

        put(lines, '{perc} {pos} / {size} {rate} {more_time} {name} [{command}]',
            perc=percentage(now_fd.pos, now_fd.size),
            rate=rate,
            more_time=more_time,
            pos=gmk(now_fd.pos),
            size=gmk(now_fd.size),
            name=os.path.basename(now_fd.name),
            command=now_proc.command)
    # Any FDs still in then_proc have been closed.
    for (fd, dev, ino), then_fd in then_proc.fds.items():
        if then_fd.shown:
            put(lines, 'CLOSED - {name} [{command}]',
                name=os.path.basename(then_fd.name),
                command=then_proc.command)

def compare_procs(then_procs: Procs, now_procs: Procs) -> None:
    lines: Lines = []

    for pid, now_proc in now_procs.items():
        then_proc = then_procs.pop(pid, None)
        if then_proc:
            compare_proc(lines, then_proc, now_proc)

    # Any processes still in then_procs no longer exist.
    # Check for FDs that we previously reported but are now gone.
    for pid, then_proc in then_procs.items():
        for _, then_fd in then_proc.fds.items():
            if then_fd.shown:
                put(lines, 'CLOSED - {name} [{command}]',
                    name=os.path.basename(then_fd.name),
                    command=then_proc.command)

    if lines:
        print('\r', end='')
        for line in lines:
            print(line)

# Inspired by https://github.com/Xfennec/progress/

@click.command()
@click.option('--seconds', '-s', metavar='N', default=2, show_default=True,
              help='Time between polls')
def main(seconds: int) -> None:
    """
    Watch processes as they progress through file I/O operations.
    """

    # Don't catch SIGINT to generate KeyboardInterrupt.
    signal.signal(signal.SIGINT, signal.SIG_DFL)

    os.chdir('/proc')

    sleep = float(seconds)
    now_procs = get_procs()
    while True:
        time.sleep(sleep)
        then_procs = now_procs
        now_procs = get_procs()
        compare_procs(then_procs, now_procs)

main()                          # pylint: disable=no-value-for-parameter
